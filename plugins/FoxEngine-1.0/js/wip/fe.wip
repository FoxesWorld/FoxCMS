class FoxEngine {
    constructor(login) {
        this.selectPage = { thisPage: "", thatPage: "" };
        this.replacedTimes = 0;
        this.optNamesArr = [];
        this.elementsDir = replaceData.assets + "elements/";
    }

    async loadPage(page, block) {
        let delay, option, content, func;
        let parser = new DOMParser();

        if (page !== this.selectPage.thisPage && this.selectPage.thisPage !== undefined) {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });

            let optionContent = await this.sendPostAndGetAnswer({
                "getOption": page
            });

            optionContent.onreadystatechange = function() {
                if (optionContent.readyState === 4) {
                    FoxesInput.initialised = false;
                    let response = parser.parseFromString(this.responseText, 'text/html');
                    option = foxEngine.getData(response, 'useroption');
                    content = foxEngine.getData(response, 'pageContent');
                    
                    if (option !== undefined) {
                        let jsonOption = JSON.parse(option.textContent);
                        if (jsonOption.onLoad) {
                            switch (jsonOption.onLoadArgs) {
                                case undefined:
                                    func = jsonOption.onLoad + "()";
                                    break;

                                default:
                                    func = jsonOption.onLoad + "(" + jsonOption.onLoadArgs + ")";
                                    break;
                            }

                            setTimeout(() => {
                                eval(func);
                            }, 500);
                        }

                        foxEngine.loadData(foxEngine.replaceText(this.responseText, page), block);
                        foxEngine.setPage(page);
                        location.hash = '#page/' + page;
                    }
                }
            };
        }
    }

    async getLastUser() {
        try {
            let lastUser = await this.sendPostAndGetAnswer({
                userAction: "lastUser"
            }, "JSON");

            let userView = await this.loadAndReplaceHtml(this.elementsDir + 'lastUser.tpl', {
                colorScheme: lastUser.colorScheme,
                profilePhoto: lastUser.profilePhoto,
                login: lastUser.login,
                realname: lastUser.realname,
                regDate: this.convertUnixTime(lastUser.reg_date)
            });

            $("#lastUser").html(userView);
        } catch (error) {
            console.error(error.message);
        }
    }

    textAnimate(target) {
        let animation = anime.timeline({
            loop: false
        }).add({
            targets: target,
            scale: [14, 1],
            rotateZ: [180, 0],
            opacity: [0, 1],
            easing: "easeOutExpo",
            duration: 1000,
            delay: 500
        });

        return true;
    }

    async sendPostAndGetAnswer(requestBody, answerType) {
        try {
            let response = await request.send_post(requestBody);
            await this.waitForResponse(response);

            switch (answerType) {
                case "JSON":
                    return this.parseResponseJSON(response.responseText);
                case "HTML":
                    return this.parseResponseHTML(response.responseText);
                default:
                    throw new Error("Invalid answerType specified");
            }

        } catch (error) {
            console.error(error.message);
            throw error;
        }
    }

    waitForResponse(response) {
        return new Promise(resolve => {
            response.addEventListener("load", () => {
                resolve();
            });
        });
    }

    parseResponseJSON(responseText) {
        try {
            return JSON.parse(responseText);
        } catch (error) {
            console.error(error.message);
            throw error;
        }
    }

    parseResponseHTML(responseText) {
        try {
            return new DOMParser().parseFromString(responseText, 'text/html');
        } catch (error) {
            console.error(error.message);
            throw error;
        }
    }

    getData(data, tag) {
        return data.getElementsByTagName(tag)[0];
    }

    async userAction(action) {
        try {
            let answer = await this.sendPostAndGetAnswer({
                user_doaction: action
            }, "JSON");

            $("#actionBlock").html(answer.text + ' ' + replaceData.realname + '!');
        } catch (error) {}

        this.textAnimate("#actionBlock");
    }

    splitWrapLetters(query, letterClass) {
        let textWrapper = document.querySelector(query);
        textWrapper.innerHTML = textWrapper.textContent.replace(/\S/g, "<span class='" + letterClass + "'>$&</span>");
    }

    buttonFreeze(button, delay) {
        let oldValue = button.innerHTML;
        let spinner = '<ul class="list-inline"> <li>Ожидайте</li> <li class="wait"><div class="spinner-border" role="status"> <span class="visually-hidden">Loading...</span></div></li>';
        button.setAttribute('disabled', true);
        button.innerHTML = spinner;

        setTimeout(() => {
            button.innerHTML = oldValue;
            button.removeAttribute('disabled');
        }, delay);
    }

    soundOnClick(type) {
        let tplScan = request.send_post({
            sysRequest: "tplScan",
            path: "/assets/snd/" + type
        });

        let sndNum;
        tplScan.onreadystatechange = function() {
            if (tplScan.readyState === 4) {
                let sndAmount = JSON.parse(this.responseText).fileNum;
                sndNum = this.randomNumber(1, sndAmount);

                if (sndAmount > 0) {
                    var sound = new Howl({
                        src: [replaceData.assets + 'snd/' + type + '/sound' + sndNum + '.mp3'],
                        preload: true,
                    });

                    sound.play();
                }
            }
        };
    }

async parseUsrOptionsMenu() {
    if (this.optNamesArr.length <= this.optionAmount)
        this.debugSend('Using FoxesWorld UserOptions', 'background: #39312fc7; color: yellow; font-size: 14pt');
    if (replaceData.isLogged) {
        this.debugSend("User " + replaceData.login + " is logged", '');
    }
    try {
        let json = await this.sendPostAndGetAnswer({
            "getUserOptionsMenu": replaceData.login
        }, "JSON");
        this.optionAmount = json.optionAmount;
        this.optionArray = json.optionArray;
        if (this.optNamesArr.length <= this.optionAmount) this.debugSend("UserOptions available: " + this.optionAmount, "");
        for (var i = 0; i < this.optionAmount; i++) {
            var obj = this.optionArray[i];
            for (var optionName in obj) {
                let appendBlock = obj[optionName]["optionBlock"];
                switch (obj[optionName]["type"]) {
                    case "page":
                        this.optionTpl = `
                                      <li class="` + obj[optionName]["optionClass"] + `">
                                        <a  class="pageLink-` + optionName + `" onclick="foxEngine.loadPage('` + optionName + `', replaceData.contentBlock); return false; ">
                                            <div class="rightIcon">
                                                ` + obj[optionName]["optionPreText"] + `
                                            </div>
                                        ` + obj[optionName]["optionTitle"] + `
                                        </a>
                                        </li>`;
                        break;

                    case "pageContent":
                        break;

                    case "plainText":
                        this.optionTpl = obj[optionName]["optionTitle"];
                        break;
                }
                if (appendBlock !== undefined) {
                    $(appendBlock).append(this.optionTpl);
                }
                this.optNamesArr.push(optionName);
            }
        }
    } catch (error) {}
}

async showUserProfile(userDisplay) {
    let userProfile = await request.send_post({
        "userDisplay": userDisplay,
        "user_doaction": "ViewProfile"
    });

    userProfile.onreadystatechange = function() {
        if (userProfile.readyState === 4) {
            foxEngine.loadData(userProfile.responseText, '#content');
        }
    }
    location.hash = 'user/' + userDisplay;
    FoxesInput.initialised = false;
    FoxesInput.formInit(1000);
}

async showProfilePopup(user, dialogOptions) {
    //$("#dialog").dialog("option", "title", user);
    
        let response = await this.sendPostAndGetAnswer({
            "userDisplay": user,
            "user_doaction": "ViewProfile"
        }, "HTML");

    this.loadData(response.getElementById('view'), '#dialogContent');
    $("#dialog").dialog(dialogOptions);
    $("#dialog").dialog('open');
    setTimeout(() => {
        this.parseBadges(user);
    }, 600);
}

/*Badges*/
// Function to parse badges
async parseBadges(user) {
    let parsedJson = await this.sendPostAndGetAnswer({
        user_doaction: 'GetBadges',
        userDisplay: user
    }, "JSON");

    if (parsedJson.length > 0) {
        for (var k = 0; k < parsedJson.length; k++) {
            let obj = parsedJson[k];
            let badgeHtml = await this.loadAndReplaceHtml(this.elementsDir + 'badge.tpl', {
                BadgeDesc: obj.BadgeDesc,
                AcquiredDateFormatted: this.convertUnixTime(obj.AcquiredDate),
                BadgeName: obj.BadgeName,
                BadgeImg: obj.BadgeImg
            });
            $("#userBadges").append(badgeHtml);
            $('[data-toggle="tooltip"]').tooltip({
                placement: 'bottom',
                trigger: "hover"
            });
        }
    } else {
        $("#userBadges").remove();
    }
}

/*Servers parser*/
async parseOnline() {
    try {
        let parsedJson = await this.sendPostAndGetAnswer({
            sysRequest: 'parseMonitor'
        }, "JSON");

        if (parsedJson.servers.length > 0) {
            for (const obj of parsedJson.servers) {
                let isOnline = obj.status === "online";
                let serverHtml;

                let progressbarClass = isOnline ? 'progressbar-online' : 'progressbar-offline';
                let playersOnline = isOnline ? obj.playersOnline : 0;
                let playersMax = isOnline ? obj.playersMax : 0;
                
                serverHtml = await this.loadAndReplaceHtml(this.elementsDir + 'monitor/serverEntry.tpl', {
                    version: obj.version,
                    srvName: obj.serverName,
                    serverName: obj.serverName,
                    playersOnline: playersOnline,
                    playersMax: playersMax,
                    percent: obj.percent,
                    statusClass: isOnline ? 'online' : 'offline',
                    version: obj.version,
                    progressbarClass: progressbarClass  // Добавляем параметр progressbarClass
                });

                $("#servers").append(serverHtml);
            }

            const totalOnlineHtml = await this.loadAndReplaceHtml(this.elementsDir + 'monitor/totalOnline.tpl', {
                totalPlayersOnline: parsedJson.totalPlayersOnline,
                totalPlayersMax: parsedJson.totalPlayersMax,
                percent: parsedJson.percent,
                todaysRecord: parsedJson.todaysRecord
            });

            $("#servers").append(totalOnlineHtml);
        } else {
            $("#servers").remove();
        }
    } catch (error) {
        console.error('Error parsing online servers:', error);
        // Обработка ошибки или возврат соответствующего значения
    }
}

    debugSend(message, style) {
        console.log("%c" + message, style);
    }

    async loadAndReplaceHtml(filePath, replacements) {
        try {
            let response = await fetch(filePath);

            if (!response.ok) {
                throw new Error('Failed to load HTML content');
            }

            let htmlContent = await response.text();

            for (let key in replacements) {
                if (replacements.hasOwnProperty(key)) {
                    const regex = new RegExp('{' + key + '}', 'g');
                    htmlContent = htmlContent.replace(regex, replacements[key]);
                }
            }

            return htmlContent;
        } catch (error) {
            console.error(error.message);
            return '';
        }
    }

    loadData(data, block) {
        let Galleryinstance;
        $(block).fadeOut(500);

        setTimeout(() => {
            if (data !== undefined) {
                if (String(data).indexOf('<section class="gallery"') > 0) {
                    Galleryinstance = new Gallery(data);
                    Galleryinstance.loadGallery();
                }
            }

            $(block).html(data);
            $(block).fadeIn(500);
            FoxesInput.formInit(500);
        }, 500);
    }

    setPage(page) {
        $(".pageLink-" + page).addClass("selectedPage");

        if (page != this.selectPage.thisPage) {
            this.selectPage.thatPage = this.selectPage.thisPage;
            $(".pageLink-" + this.selectPage.thatPage).removeClass("selectedPage");
        }

        this.selectPage.thisPage = page;
    }

    convertUnixTime(unix) {
        let a = new Date(unix * 1000),
            year = a.getFullYear(),
            months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
            month = months[a.getMonth()],
            date = a.getDate(),
            hour = a.getHours(),
            min = a.getMinutes() < 10 ? '0' + a.getMinutes() : a.getMinutes(),
            sec = a.getSeconds() < 10 ? '0' + a.getSeconds() : a.getSeconds();

        return `${month} ${date}, ${year}, ${hour}:${min}:${sec}`;
    }

    randomNumber(min, max) {
        const r = Math.random() * (max - min) + min + 1;
        return Math.floor(r);
    }

    replaceText(text, page) {
        let updatedText = text;

        for (let j = 0; j < userFields.length; j++) {
            let value = userFields.at(j);
            let mask = "%" + value + "%";

            while (updatedText.includes(mask) > 0) {
                this.debugSend(" - Replacing " + value + " mask...", 'color: green');
                updatedText = updatedText.replace(mask, replaceData[userFields.at(j)]);
                this.replacedTimes++;
            }
        }

        switch (this.replacedTimes) {
            case 0:
                this.debugSend("No text for replacing was found", 'color: red');
                break;

            case 1:
                this.debugSend("Replaced " + this.replacedTimes + " occurrence", 'color: green');
                break;

            default:
                this.debugSend("Replaced " + this.replacedTimes + " occurrences", 'color: green');
                break;
        }

        this.replacedTimes = 0;
        return updatedText;
    }

    async parseEmojis() {
        try {
            let emojiHTML = `<div class="emoji_box">`;

            let emojiData = await this.sendPostAndGetAnswer({
                sysRequest: 'parseEmojis'
            });

            if (emojiData && emojiData.emoji && Array.isArray(emojiData.emoji)) {
                let emojiArray = emojiData.emoji;

                for (let emoji of emojiArray) {
                    if (emoji && emoji.code && emoji.name) {
                        let code = emoji.code;
                        let name = emoji.name;

                        emojiHTML += `<div class="emoji_symbol" data-emoji="${code}" title="${name}"></div>`;
                    } else {
                        console.error('Invalid emoji structure:', emoji);
                    }
                }

                emojiHTML += `</div>`;
            } else {
                console.error('Invalid emoji data:', emojiData);
            }

            return emojiHTML;
        } catch (error) {
            console.error('Error parsing emojis:', error);
            throw error;
        }
    }
}
